<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="A Magic: the Gathering daily game" />
  <meta name="keywords" content="Magic the Gathering, MTG, card game, daily game, EDHRec, Commander, EDH, Asmoranomardicadaistinaculdacar, card popularity, Underworld Cookbook, Scrandle" />
  <meta name="author" content="Asmrandle" />
  <meta name="robots" content="index, follow" />
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://asmrandle.com/" />
  <meta property="og:title" content="Asmrandle - A Magic: the Gathering Daily Game" />
  <meta property="og:description" content="A Magic: the Gathering daily game" />
  <meta property="og:image" content="https://asmrandle.com/favicons/web-app-manifest-512x512.png" />
  <meta property="og:site_name" content="Asmrandle" />
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary" />
  <meta property="twitter:url" content="https://asmrandle.com/" />
  <meta property="twitter:title" content="Asmrandle - A Magic: the Gathering Daily Game" />
  <meta property="twitter:description" content="A Magic: the Gathering daily game" />
  <meta property="twitter:image" content="https://asmrandle.com/favicons/web-app-manifest-512x512.png" />
  
  <!-- Favicons -->
  <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico" />
  <link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96x96.png" />
  <link rel="icon" type="image/svg+xml" href="/favicons/favicon.svg" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/favicons/web-app-manifest-192x192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="/favicons/web-app-manifest-512x512.png" />
  <meta name="apple-mobile-web-app-title" content="Asmrandle" />
  <link rel="manifest" href="/favicons/site.webmanifest" />
  
  <title>Asmrandle</title>
  <style>
    
    body {
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      /*min-height: 100vh; */
      position: relative;
      padding-bottom: 120px; /* Space for fixed footer on wide screens */
    }
    .scoreboard {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 20px;
    }
    .dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: gray;
    }
    .game-area {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
      margin-top: 40px;
    }
    .card {
      position: relative;
      cursor: pointer;
    }
    .card img {
      width: 250px;
      height: auto;
      border-radius: 8px;
      transition: transform 0.2s;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.5em;
      font-weight: bold;
      border-radius: 8px;
    }
    .rules {
      margin-top: 40px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .edhrec-link {
      color: #646cdd;
    }
    .edhrec-link:visited {
      color: #8053b4;
    }
    h1 {
      font-size: 3em;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 1.2em;
      margin: 10px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      color: white;
      transition: background-color 0.3s;
    }
    #start-daily {
      background-color: #2a9d8f;
    }
    #start-daily:hover {
      background-color: #3cbca9;
    }
    #play-random {
      background-color: #e76f51;
    }
    #play-random:hover {
      background-color: #f08061;
    }
    #result {
      display: none;
      margin-top: 40px;
    }
    #copy-results {
      background-color: #264653;
    }
    #copy-results:hover {
      background-color: #3a5a73;
    }
    #play-again {
      background-color: #3d953d;
      color: black;
    }
    #play-again:hover {
      background-color: #5eb75e;
    }

    .flavorOverlay {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      font-size: 0.9em;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      box-sizing: border-box;
      max-height: 40%;
      overflow-y: auto;
      font-style: italic;
    }
    
    /* Responsive design for narrow screens */
    @media (max-width: 550px) {
      body {
        padding-bottom: 0; /* Remove fixed footer spacing on narrow screens */
      }
      .game-area {
        flex-direction: column;
        gap: 20px;
        padding: 0 20px;
      }
      .card img {
        width: min(250px, calc(100vw - 40px));
        max-width: 250px;
      }
      h1 {
        font-size: 2.5em;
      }
      .footer {
        position: static; /* Normal flow on narrow screens */
        margin-top: 50px;
      }
    }

  /* Footer styles */
    .footer {
      margin-top: 50px;
      padding: 20px;
      color: #ccc;
      font-size: 0.65em;
      border-top: 1px solid #444;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }

    /* Footer positioning for medium screens */
    @media (min-width: 551px) and (max-width: 1279px) {
      .footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        margin-top: 0;
        background: #111;
        border-top: 1px solid #444;
        max-width: 100%;
        z-index: 1000;
      }
    }
    
    /* Footer positioning for wide screens */
    @media (min-width: 1280px) {
      .footer {
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        margin-top: 0;
        background: #111;
        border-top: 1px solid #444;
        max-width: 800px;
        z-index: 1000;
      }
    }
    .footer a {
      color: #ccc;
      text-decoration: none;
      margin-right: 10px;
    }
    .footer a img {
      width: 24px;
      height: 24px;
      vertical-align: middle;
    }
    .footer p {
      margin-top: 10px;
      line-height: 1.4;
    }

  /* Result breakdown styles */
    #result-breakdown {
      margin-top: 30px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .result-item {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 32px;
      margin-bottom: 30px;
      padding: 20px;
      border-radius: 12px;
    }

    .result-item-winner {
      background: rgba(74, 222, 128, 0.25);
    }

    .result-item-loser {
      background: rgba(239, 68, 68, 0.25);
    }
    .result-card {
      position: relative;
    }

    .result-card img {
      width: 200px;
      height: auto;
      border-radius: 8px;
      display: block;
    }

    .result-winner img {
      border: 3px solid #4ade80;
    }

    .result-loser img {
      border: 3px solid #ef4444;
    }

    .result-popularity-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1em;
      font-weight: bold;
      border-radius: 8px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .result-winner .result-popularity-overlay {
      background: rgba(74, 222, 128, 0.25);
      color: #ffffff;
    }

    .result-loser .result-popularity-overlay {
      background: rgba(239, 68, 68, 0.25);
      color: #ffffff;
    }

    .result-pair-number {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.9em;
      font-weight: bold;
      opacity: 0.8;
      z-index: 10;
    }

    /* Responsive design for result breakdown */
    @media (max-width: 550px) {
      .result-item {
        flex-direction: column;
        gap: 20px;
      }
      .result-card img {
        width: min(200px, calc(100vw - 80px));
      }
    }

    /* Community results styles with sliding animation */
    #community-results {
      display: none;
      margin: 30px auto;
      max-width: 600px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      overflow: hidden;
    }

    .community-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      user-select: none;
    }

    .community-header:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .community-header h4 {
      margin: 0;
      color: #ffffff;
      font-size: 1.3em;
    }

    .toggle-arrow {
      font-size: 1.2em;
      transition: transform 0.3s ease;
      color: #cccccc;
    }

    .toggle-arrow.expanded {
      transform: rotate(90deg);
    }

    .community-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease-out;
      padding: 0 15px;
    }

    .community-content.expanded {
      max-height: 500px;
      padding: 0 15px 15px;
    }



    .bar-graph {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 15px 0;
    }

    .bar-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .bar-label {
      min-width: 20px;
      font-size: 0.9em;
      color: #cccccc;
      text-align: right;
    }

    .bar-container {
      flex-grow: 1;
      height: 25px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #3d953d, #5eb75e);
      border-radius: 4px;
      transition: width 0.8s ease-in-out;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
      position: relative;
    }

    .bar-fill-hard {
      position: absolute;
      right: 0;
      top: 0;
      height: 100%;
      background: linear-gradient(90deg, #8b5cf6, #a855f7);
      border-top-right-radius: 4px;
      border-bottom-right-radius: 4px;
      transition: width 0.8s ease-in-out;
    }

    .bar-fill-user {
      background: linear-gradient(90deg, #4c8ea8, #4f82a8);
    }

    .bar-fill-hard-user {
      background: linear-gradient(90deg, #4c8ea8, #4f82a8);
    }

    .bar-fill-first10 {
      background: linear-gradient(90deg, #fda325, #fdc313);
    }

    .bar-fill-hard-first10 {
      background: linear-gradient(90deg, #b45309, #d97706);
    }

    .bar-count {
      color: white;
      font-weight: bold;
      font-size: 0.8em;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      position: relative;
      z-index: 1;
    }

    .total-players {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 0.9em;
      color: #cccccc;
    }

    .mode-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 10px 0;
      font-size: 0.8em;
      color: #cccccc;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 2px;
    }

    .legend-normal {
      background: linear-gradient(90deg, #3d953d, #5eb75e);
    }

    .legend-hard {
      background: linear-gradient(90deg, #8b5cf6, #a855f7);
    }

    .legend-user {
      background: linear-gradient(90deg, #4c8ea8, #4f82a8);
    }

    @media (max-width: 550px) {
      #community-results {
        margin: 20px 10px;
      }
      
      .community-header {
        padding: 12px;
      }
      
      .community-header h4 {
        font-size: 1.1em;
      }
      
      .community-content.expanded {
        padding: 0 12px 12px;
      }
      .bar-label {
        font-size: 0.8em;
        min-width: 18px;
      }
      .bar-container {
        height: 22px;
        /* Fix Android Chrome rendering issues */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
      }
      .bar-fill {
        /* Improve Android Chrome animation performance */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        will-change: width;
      }
      .bar-count {
        font-size: 0.7em;
        /* Improve text rendering on Android */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      .bar-graph {
        gap: 6px;
      }
    }
  </style>
  
  <!-- Structured Data for SEO -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Asmrandle",
    "description": "A Magic: the Gathering daily game",
    "url": "https://asmrandle.com",
    "applicationCategory": "Game",
    "operatingSystem": "Web Browser",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "author": {
      "@type": "Organization",
      "name": "Asmrandle"
    },
    "keywords": "Magic the Gathering, MTG, card game, daily game, EDHRec, Commander, EDH, Asmoranomardicadaistinaculdacar, card popularity, Underworld Cookbook, Scrandle",
    "genre": "Card Game",
    "inLanguage": "en-US"
  }
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/counterapi/dist/counter.browser.min.js"></script>
</head>
<body>
  <h1>Asmrandle</h1>
  <div class="main-menu" id="main-menu">
    <div>
      <button id="start-daily" onClick="loadCards('daily')">Play Daily</button>
      <button id="play-random" onClick="loadCards()">Practice</button>
    </div>
    <div>
      <input type="checkbox" id="hard-mode" />
      <label for="hard-mode">Hard Mode</label>
    </div>
  </div>
  <div class="scoreboard" id="scoreboard"></div>
  <div class="game-area" id="game"></div>
  <div id="result">
    <h2 id="result-text"></h2>
    <h3 id="time-to-next-daily"></h3>
    <button id="copy-results" onClick="copyToKeyboard()">Copy Results</button>
    <button id="play-again" onClick="location.reload()">Play Again</button>
    <div id="community-results"></div>
    <div id="result-breakdown"></div>
  </div>
  <div class="rules" id="rules">
    <h3>How to Play</h3>
    <p>Click on the card you believe appears in a higher percentage of decks on <a href="https://edhrec.com" class="edhrec-link" rel="noopener noreferrer" target="_blank">EDHRec</a>. 
      This percentage represents how often a card is included in decks where it's eligible to be played â€” calculated by dividing the number of decks that include the card by the total number of decks it could appear in.</p>
  </div>
  <div class="footer">
    <!--LinkedIn-->
    <a href="https://www.linkedin.com/in/julienplegault/" target="_blank" rel="noopener noreferrer" id="linkedin-link"><img src="images/InBug-White.png" alt="LinkedIn" /></a>
    <!--GitHub-->
    <a href="https://github.com/julienlegault/Asmrandle" target="_blank" rel="noopener noreferrer" id="github-link"><img src="images/Github-Mark-White.png" alt="GitHub" /></a>
    <p>Portions of Asmrandle are unofficial Fan Content permitted under the Wizards of the Coast Fan Content Policy. The literal and graphical information presented on this site about Magic: The Gathering, including card images and mana symbols, is copyright Wizards of the Coast, LLC. Asmrandle is not produced by or endorsed by Wizards of the Coast.</p>
  </div>

  <!-- Load card list -->
  <script src="./formatted_card_list.js"></script>
  
  <script>

    const mainMenu = document.getElementById("main-menu");
    const scoreboard = document.getElementById("scoreboard");
    const gameArea = document.getElementById("game");
    const result = document.getElementById("result");
    const resultText = document.getElementById("result-text");
    const timeToNextDaily = document.getElementById("time-to-next-daily");
    const copyResultsBtn = document.getElementById("copy-results");
    const rules = document.getElementById("rules");

    let cardData = [];
    let currentPair = 0;
    let correctCount = 0;
    let gameType = 0; // 0 = practice, 1 = daily
    let resultToCopy = "";
    let shuffled = [];
    let hardMode = false;
    let resultArray = [];

    // Use the current date (YYYYMMDD) in Central Time as a seed
    // We use Intl.DateTimeFormat with the "America/Chicago" timezone so the daily seed follows Central Time (CST/CDT)
    const now = new Date();
    const centralFormatter = new Intl.DateTimeFormat('en-US', {
      timeZone: 'America/Chicago',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });
    const parts = centralFormatter.formatToParts(now);
    const getPart = (type) => parts.find(p => p.type === type)?.value || '';
    const yyyy = getPart('year');
    const mm = getPart('month');
    const dd = getPart('day');
    const dateStr = `${yyyy}-${mm}-${dd}`;
    const dateStrSanatized = `${yyyy}${mm}${dd}`;
    let counter;

    document.addEventListener("DOMContentLoaded", () => {
      counter = new Counter({workspace: "asmrandle"});
    });

    // Simple seeded RNG using Mulberry32
    function mulberry32(seed) {
      let t = seed;
      return function() {
        t |= 0;
        t = (t + 0x6D2B79F5) | 0;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r = (r + Math.imul(r ^ (r >>> 7), 61 | r)) ^ r;
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    // Convert the date string into a numeric seed
    let seed = dateStrSanatized;
    let rng = mulberry32(parseInt(seed));

    // Shuffle using the seeded RNG (Fisher-Yates)
    function shuffleSeeded(array, rng) {
      let a = array.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    async function getCount(score, hm = false, retries = 2) {
      try {
        // Ensure counter is initialized (critical for Android Chrome)
        if (!counter) {
          counter = new Counter({workspace: "asmrandle"});
        }
        let data;
        if (hm) {
          data = await counter.get(`dailyhm${score}`);
        } else {
          data = await counter.get(`daily${score}`);
        }
        return data.data.up_count;
      } catch (error) {
        
        // Retry on mobile networks (common issue with Android Chrome)
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
          return getCount(score, hm, retries - 1);
        }
        return 0;
      }
    }

    function increaseCount(score = -1) {
      // Ensure counter is initialized (critical for Android Chrome)
      if (!counter) {
        counter = new Counter({workspace: "asmrandle"});
      }
      
      if (score >= 0) {
        if (hardMode) {
          counter.up(`dailyhm${score}`).catch(() => {
            // Ignore any errors
          });
        } else {
          counter.up(`daily${score}`).catch(() => {
            // Ignore any errors
          });
        }
      }
      counter.up(`plays`).catch(() => {
        // Ignore any errors
      });
    }

    // Cookie utility functions
    function setCookie(name, value, days) {
      let expires = "";
      if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
    }

    function getCookie(name) {
      const nameEQ = name + "=";
      const ca = document.cookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    }

    function getDigitLength(card, card2) {
      let found = false;
      let length = 3;
      while (!found && length <= 6) {
        const factor = Math.pow(10, length);
        const pop1 = Math.floor(card.popularity * factor);
        const pop2 = Math.floor(card2.popularity * factor);
        if (pop1 !== pop2 && pop1 !== 0) {
          found = true;
        } else {
          length++;
        }
      }
      return length;
    }

    function floorToDigits(num, digits) {
       const factor = Math.max(10 ** digits, 10);
       return Math.floor(num * factor) / factor;
    }
    
    function getTimeToNextDaily() {
      const now = new Date();
      const centralNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
      const nextDaily = new Date(centralNow);
      nextDaily.setHours(24, 0, 0, 0); // Set to midnight next day
      const diffMs = nextDaily - centralNow;
      const hours = Math.floor(diffMs / (1000 * 60 * 60));
      const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
      return {
        formatted: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`,
        milliseconds: diffMs
      };
    }

    function updateCountdown() {
      if (timeToNextDaily) {
        const timeData = getTimeToNextDaily();
        timeToNextDaily.textContent = `Time to next daily: ${timeData.formatted}`;
        
        // Stop countdown if less than 1 second remaining
        if (timeData.milliseconds <= 1000) {
          stopCountdown();
          document.location.reload();
        }
      }
    }

    // Start countdown timer
    let countdownInterval;
    function startCountdown() {
      updateCountdown(); // Update immediately
      countdownInterval = setInterval(updateCountdown, 1000); // Update every second
    }

    function stopCountdown() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    async function fetchCardData(idx) {
      const name = shuffled[idx++];
        try {
          const cardRes = await fetch(`https://json.edhrec.com/pages/cards/${name}.json`);
          if (!cardRes.ok) return fetchCardData(20 +idx);
          const data = await cardRes.json();
          const card = data?.container?.json_dict?.card;
          if (!card) return fetchCardData(20 +idx);
          const inclusion = parseFloat(card.inclusion);
          const potential = parseFloat(card.potential_decks);
          let flavorText = "No flavor text available";
          let imageUrl = card.image_uris?.[0]?.normal || null;
          let artImg = null;
          if (hardMode) {
            try {
              const scryfallRes = await fetch(`https://api.scryfall.com/cards/${card.id}`);
              if (!scryfallRes.ok) return fetchCardData(20 +idx);
              const scryfallData = await scryfallRes.json();
              flavorText = scryfallData?.flavor_text || "No flavor text available";
              artImg = scryfallData?.image_uris?.art_crop || scryfallData?.card_faces?.[0]?.image_uris?.art_crop || imageUrl;
            } catch (err) {
              return fetchCardData(20 +idx);
            }
          }
          if (!isFinite(inclusion) || !isFinite(potential) || potential === 0) return fetchCardData(20 +idx);
          const popularity = (inclusion / potential) * 100;
          return ({
            name,
            popularity,
            img: imageUrl,
            artImg,
            flavorText
          });
        } catch (err) {
          // on network / parse error, skip this card and continue
          return fetchCardData(20 +idx);
        }
    }

    function fetchAllCardData() {
      const promises = [];
      for (let i = 0; i < 20; i++) {
        promises.push(fetchCardData(i).then(data => {
          cardData[i] = data;
        }));
      }
      return Promise.all(promises);
    }

    async function showCommunityResults(replay=false) {
      const communityResults = document.getElementById("community-results");
      communityResults.innerHTML = "";
      
      try {
        
        // Add timeout for mobile reliability
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout after 10 seconds')), 10000)
        );
        // Fetch all counts concurrently with timeout
        const countPromises = [];
        for (let i = 0; i <= 10; i++) {
          countPromises.push(getCount(i));
        }
        const hardModePromises = [];
        for (let i = 0; i <= 10; i++) {
          hardModePromises.push(getCount(i, true));
        }
        
        const counts = await Promise.race([
          Promise.all(countPromises),
          timeoutPromise
        ]);

        const hardModeCounts = await Promise.race([
          Promise.all(hardModePromises),
          timeoutPromise
        ]);
        
        // Calculate total players (normal + hard mode)
        let totalPlayers = 0;
        for (let i = 0; i <= 10; i++) {
          totalPlayers += counts[i] + hardModeCounts[i];
        }
        let isFirst10 = false;
        if(counts[10]==0 && hardModeCounts[10]==0 && correctCount==10){
           resultText.textContent = `${dateStr} | âœ¨ Today's first 10 âœ¨`;
           resultToCopy = `âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨ | Today's First 10 ${hardMode? "| Hard Mode " : ""}| ${dateStr} | https://asmrandle.com`;
           isFirst10 = true;
        }
        if (totalPlayers !== 0) {
          communityResults.style.display = "block"; // Show if data exists
        }

        if(!replay){
           totalPlayers++;
           if (hardMode) {
             hardModeCounts[correctCount]++;
           } else {
             counts[correctCount]++;
           }
        }

        // Create header with toggle functionality
        const header = document.createElement("div");
        header.className = "community-header";
        header.onclick = toggleCommunityResults;
        
        const title = document.createElement("h4");
        title.textContent = "Today's Community Results";
        
        const arrow = document.createElement("span");
        arrow.className = "toggle-arrow";
        arrow.textContent = "â–¶";
        
        header.appendChild(title);
        header.appendChild(arrow);
        communityResults.appendChild(header);
        
        // Create content container
        const content = document.createElement("div");
        content.className = "community-content";
        content.id = "community-content";
        
        // Find max count for scaling bars (total of normal + hard mode)
        const totalCounts = counts.map((count, i) => count + hardModeCounts[i]);
        const maxCount = Math.max(...totalCounts, 1); // Ensure at least 1 to avoid division by zero
        
        // Create bar graph container
        const barGraph = document.createElement("div");
        barGraph.className = "bar-graph";
        
        // Create bars for scores 0-10
        for (let i = 0; i < 11; i++) {
          const score = i;
          const normalCount = counts[i];
          const hardCount = hardModeCounts[i];
          const totalCount = normalCount + hardCount;
          const percentage = maxCount > 0 ? (totalCount / maxCount) * 100 : 0;
          
          // Create bar item container
          const barItem = document.createElement("div");
          barItem.className = "bar-item";
          
          // Create label
          const barLabel = document.createElement("div");
          barLabel.className = "bar-label";
          barLabel.textContent = `${score}`;
          
          // Create bar container
          const barContainer = document.createElement("div");
          barContainer.className = "bar-container";
          
          // Create bar fill (total plays)
          const barFill = document.createElement("div");
          // Only apply user color to normal plays if user played normal mode
          const isUserNormalPlay = score === correctCount && !hardMode;
          barFill.className = `bar-fill ${isUserNormalPlay ? 'bar-fill-user' : ''} ${isFirst10 ? 'bar-fill-first10' : ''}`;
          barFill.style.width = `${percentage}%`;
          
          // Create hard mode fill (purple section at the end)
          if (hardCount > 0 && totalCount > 0) {
            const hardPercentage = (hardCount / totalCount) * 100;
            const hardFill = document.createElement("div");
            // Only apply user color to hard mode plays if user played hard mode
            const isUserHardPlay = score === correctCount && hardMode;
            hardFill.className = `bar-fill-hard ${isUserHardPlay ? 'bar-fill-hard-user' : ''} ${isFirst10 ? 'bar-fill-hard-first10' : ''}`;
            hardFill.style.width = `${hardPercentage}%`;
            barFill.appendChild(hardFill);
          }
          
          // Create count text
          const barCount = document.createElement("span");
          barCount.className = "bar-count";
          barCount.textContent = totalCount > 0 ? totalCount.toString() : '';
          
          // Assemble the bar
          barFill.appendChild(barCount);
          barContainer.appendChild(barFill);
          barItem.appendChild(barLabel);
          barItem.appendChild(barContainer);
          barGraph.appendChild(barItem);
        }
        
        // Add legend for normal vs hard mode
        const legend = document.createElement("div");
        legend.className = "mode-legend";
        
        const normalLegend = document.createElement("div");
        normalLegend.className = "legend-item";
        const normalColor = document.createElement("div");
        normalColor.className = "legend-color legend-normal";
        const normalText = document.createElement("span");
        normalText.textContent = "Normal plays";
        normalLegend.appendChild(normalColor);
        normalLegend.appendChild(normalText);
        
        const hardLegend = document.createElement("div");
        hardLegend.className = "legend-item";
        const hardColor = document.createElement("div");
        hardColor.className = "legend-color legend-hard";
        const hardText = document.createElement("span");
        hardText.textContent = "Hard mode plays";
        hardLegend.appendChild(hardColor);
        hardLegend.appendChild(hardText);
        
        const userLegend = document.createElement("div");
        userLegend.className = "legend-item";
        const userColor = document.createElement("div");
        userColor.className = "legend-color legend-user";
        const userText = document.createElement("span");
        userText.textContent = "Your score";
        userLegend.appendChild(userColor);
        userLegend.appendChild(userText);
        
        legend.appendChild(normalLegend);
        legend.appendChild(hardLegend);
        legend.appendChild(userLegend);
        
        content.appendChild(legend);
        
        content.appendChild(barGraph);
        
        // Add total players count
        const totalDiv = document.createElement("div");
        totalDiv.className = "total-players";
        let betterThan = 0;
        for (let i = 0; i < correctCount; i++) {
          betterThan += counts[i] + hardModeCounts[i];
        }
        totalDiv.textContent = `Total players today: ${totalPlayers} | You scored better than ${(betterThan / totalPlayers * 100).toFixed(2)}% of players`;
        content.appendChild(totalDiv);
        
        // Append content to community results
        communityResults.appendChild(content);
        
      } catch (error) {
      }
    }

    function toggleCommunityResults() {
      const content = document.getElementById("community-content");
      const arrow = document.querySelector(".toggle-arrow");
      
      if (content && arrow) {
        if (content.classList.contains("expanded")) {
          content.classList.remove("expanded");
          arrow.classList.remove("expanded");
        } else {
          content.classList.add("expanded");
          arrow.classList.add("expanded");
        }
      }
    }

    function showResultBreakdown() {
      const resultBreakdown = document.getElementById("result-breakdown");
      for (let i = 0; i < 10; i++) {
        const correct = resultArray[i];
        const div = document.createElement("div");
        div.className = "result-item";
        div.classList.add(correct ? "result-item-winner" : "result-item-loser");
        div.style.position = "relative";
        
        // Create pair number element
        const pairNumber = document.createElement("div");
        pairNumber.className = "result-pair-number";
        pairNumber.textContent = `#${i + 1}`;
        div.appendChild(pairNumber);
        
        const card = cardData[i * 2];
        const card2 = cardData[i * 2 + 1];
        
        // Create first card container
        const card1Container = document.createElement("div");
        card1Container.className = "result-card";
        const img1 = document.createElement("img");
        img1.src = card.img;
        const winner = card.popularity >= card2.popularity;
        if (winner) {
          card1Container.classList.add("result-winner");
        } else {
          card1Container.classList.add("result-loser");
        }
        const overlay1 = document.createElement("div");
        overlay1.className = "result-popularity-overlay";
        overlay1.textContent = `${floorToDigits(card.popularity, getDigitLength(card, card2))}%`;
        card1Container.appendChild(img1);
        card1Container.appendChild(overlay1);
        
        // Create second card container
        const card2Container = document.createElement("div");
        card2Container.className = "result-card";
        const img2 = document.createElement("img");
        img2.src = card2.img;
        if (!winner) {
          card2Container.classList.add("result-winner");
        } else {
          card2Container.classList.add("result-loser");
        }
        const overlay2 = document.createElement("div");
        overlay2.className = "result-popularity-overlay";
        overlay2.textContent = `${floorToDigits(card2.popularity, getDigitLength(card2, card))}%`;
        card2Container.appendChild(img2);
        card2Container.appendChild(overlay2);
        
        div.appendChild(card1Container);
        div.appendChild(card2Container);
        resultBreakdown.appendChild(div);
      }
    }

    async function loadCards(type) {
      hardMode = document.querySelector("#hard-mode").checked;
      mainMenu.style.display = "none";
      if (type === 'daily') {
        todayCookie = getCookie(`${dateStrSanatized}`);
        shuffled = shuffleSeeded(window.cardList, rng); // shuffle with seed for daily mode
        if (todayCookie !== null) {
          await fetchAllCardData();
          resultArray = todayCookie.split("|")[0].split(",").map(item => item === 'true');
          hardMode = todayCookie.split("|").includes("HM");
          if (resultArray.length !== 10) {
            resultArray = Array(10).fill(false);
          }
          correctCount = resultArray.filter(item => item).length;
          resultToCopy = "";
          for (let i = 0; i < 10; i++) {
            resultToCopy += resultArray[i] ? "ðŸŸ©" : "ðŸŸ¥";
          }
          resultToCopy += ` ${correctCount}/10`;
          resultText.textContent = `You have already played today's Asmrandle! Your score was ${correctCount}/10.`;
          startCountdown(); // Start the live countdown timer
          resultToCopy += ` ${hardMode?'| Hard Mode ':''}| ${dateStr} | https://asmrandle.com`;
          gameArea.style.display = "none";
          result.style.display = "block";
          showCommunityResults(true);
          showResultBreakdown();
          return;
        }
        gameType = 1;
      } else {
        shuffled = [...window.cardList].sort(() => 0.5 - Math.random()); // shuffle full list
      }

      let idx = 0;
      while (idx < 20) {
        const name = shuffled[idx++];
        cardData.push({
          name,
          popularity: null,
          img: null,
          artImg: null,
          flavorText: null
        });
      }

      await fetchCardData(0).then(data => {
        cardData[0] = data;
      });
      await fetchCardData(1).then(data2 => {
        cardData[1] = data2;
      });
      for (let i = 0; i < 10; i++) {
        const dot = document.createElement("div");
        dot.className = "dot";
        scoreboard.appendChild(dot);
      }
      showNextPair();
    }

    function saveResults() {
        if (gameType === 1) {
          increaseCount(correctCount);
          copyResultsBtn.style.display = "inline-block";
          setCookie(`${dateStrSanatized}`, `${resultArray}|${correctCount}${hardMode?'|HM':''}`, 30); // Set cookie for 30 days
          showResults();
        } else {
          increaseCount();
          copyResultsBtn.style.display = "none";
          showResults();
        }
        return;
    }

    function showResults() {
      gameArea.style.display = "none";
      result.style.display = "block";
      if (gameType === 1) {
        resultText.textContent = `${dateStr} | ${correctCount}/10 correct`;
        startCountdown(); // Start the live countdown timer
        resultToCopy += ` ${correctCount}/10 ${hardMode? "| Hard Mode " : ""}| ${dateStr} | https://asmrandle.com`
        showCommunityResults();
      } else {
        resultText.textContent = `You got ${correctCount}/10 correct.`;
      }
      showResultBreakdown();
    }

    function showNextPair() {
      if (currentPair >= 10) {
        saveResults();
        return;
      }

      gameArea.innerHTML = "";
      const card1 = cardData[currentPair * 2];
      const card2 = cardData[currentPair * 2 + 1];

      [card1, card2].forEach((card, i) => {
        const div = document.createElement("div");
        div.className = "card";
        const img = document.createElement("img");
        img.src = hardMode ? card.artImg : card.img;
        div.appendChild(img);
        if (hardMode) {
          const overlay = document.createElement("div");
          overlay.className = "flavorOverlay";
          overlay.textContent = `${card.flavorText}`;
          div.appendChild(overlay);
        }
        div.onclick = () => handleChoice(i === 0 ? card1 : card2, i === 0 ? card2 : card1, div);
        gameArea.appendChild(div);
      });
    }

    function copyToKeyboard() {
      navigator.clipboard.writeText(resultToCopy);
    }

    async function handleChoice(chosen, other, div) {
      gameArea.querySelectorAll(".card").forEach(c => c.onclick = null);
      const overlays = [];
      const cards = document.querySelectorAll(".card");

      cards.forEach((c, i) => {
        const overlay = document.createElement("div");
        overlay.className = "overlay";
        const isChosen = (i === 0 && chosen === cardData[currentPair*2]) || (i === 1 && chosen === cardData[currentPair*2+1]);
        const card = isChosen ? chosen : other;
        const higherPopularity = cardData[currentPair*2].popularity > cardData[currentPair*2+1].popularity;
        const color = higherPopularity && card === cardData[currentPair*2] || !higherPopularity && card === cardData[currentPair*2+1] ? "rgba(0,128,0,0.6)" : "rgba(128,0,0,0.6)";
        overlay.style.background = color;
        overlay.textContent = `${floorToDigits(card.popularity, getDigitLength(card, cardData[currentPair*2 + (i === 0 ? 1 : 0)]))}%`;
        c.appendChild(overlay);
        overlays.push(overlay);
      });

      const correct = chosen.popularity >= other.popularity;
      scoreboard.children[currentPair].style.background = correct ? "green" : "red";
      if (correct) {
        correctCount++
        resultToCopy += "ðŸŸ©";
        resultArray[currentPair] = true;
      } else {
        resultToCopy += "ðŸŸ¥";
        resultArray[currentPair] = false;
      };

      currentPair++;
      const idx1 = currentPair * 2;
      const idx2 = idx1 + 1;
      const startWait = Date.now();
      await fetchCardData(idx1).then(data => {
          cardData[idx1] = data;
      });
      await fetchCardData(idx2).then(data2 => {
          cardData[idx2] = data2;
      });
      const elapsed = Date.now() - startWait;
      const waitTime = Math.max(200 - elapsed, 0);
      setTimeout(() => {
        overlays.forEach(o => o.remove());
        showNextPair();
      }, waitTime);
    }
  </script>
</body>
</html>






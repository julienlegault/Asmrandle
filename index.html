<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicons/favicon.svg" />
  <link rel="shortcut icon" href="/favicons/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-title" content="Asmrandle" />
  <link rel="manifest" href="/favicons/site.webmanifest" />
  <title>Asmrandle</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    .scoreboard {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 20px;
    }
    .dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: gray;
    }
    .game-area {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
      margin-top: 40px;
    }
    .card {
      position: relative;
      cursor: pointer;
    }
    .card img {
      width: 250px;
      height: auto;
      border-radius: 8px;
      transition: transform 0.2s;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.5em;
      font-weight: bold;
      border-radius: 8px;
    }
    .rules {
      margin-top: 40px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
    }
    h1 {
      font-size: 3em;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 1.2em;
      margin: 10px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      color: white;
      transition: background-color 0.3s;
    }
    #start-daily {
      background-color: #2a9d8f;
    }
    #start-daily:hover {
      background-color: #3cbca9;
    }
    #play-random {
      background-color: #e76f51;
    }
    #play-random:hover {
      background-color: #f08061;
    }
    #result {
      display: none;
      margin-top: 40px;
    }
    #copy-results {
      background-color: #264653;
    }
    #copy-results:hover {
      background-color: #3a5a73;
    }
    #play-again {
      background-color: #3d953d;
      color: black;
    }
    #play-again:hover {
      background-color: #5eb75e;
    }

    .flavorOverlay {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      font-size: 0.9em;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      box-sizing: border-box;
      max-height: 40%;
      overflow-y: auto;
      font-style: italic;
    }
    
    /* Responsive design for narrow screens */
    @media (max-width: 550px) {
      .game-area {
        flex-direction: column;
        gap: 20px;
        padding: 0 20px;
      }
      .card img {
        width: min(250px, calc(100vw - 40px));
        max-width: 250px;
      }
      h1 {
        font-size: 2.5em;
      }
    }

  /* Result breakdown styles */
    #result-breakdown {
      margin-top: 30px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .result-item {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 32px;
      margin-bottom: 30px;
      padding: 20px;
      border-radius: 12px;
    }

    .result-item-winner {
      background: rgba(74, 222, 128, 0.25);
    }

    .result-item-loser {
      background: rgba(239, 68, 68, 0.25);
    }
    .result-card {
      position: relative;
    }

    .result-card img {
      width: 200px;
      height: auto;
      border-radius: 8px;
      display: block;
    }

    .result-winner img {
      border: 3px solid #4ade80;
    }

    .result-loser img {
      border: 3px solid #ef4444;
    }

    .result-popularity-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1em;
      font-weight: bold;
      border-radius: 8px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .result-winner .result-popularity-overlay {
      background: rgba(74, 222, 128, 0.25);
      color: #ffffff;
    }

    .result-loser .result-popularity-overlay {
      background: rgba(239, 68, 68, 0.25);
      color: #ffffff;
    }

    /* Responsive design for result breakdown */
    @media (max-width: 550px) {
      .result-item {
        flex-direction: column;
        gap: 20px;
      }
      .result-card img {
        width: min(200px, calc(100vw - 80px));
      }
    }
  </style>
</head>
<body>
  <h1>Asmrandle</h1>
  <div class="main-menu" id="main-menu">
    <div>
      <button id="start-daily" onClick="loadCards('daily')">Play Daily</button>
      <button id="play-random" onClick="loadCards()">Practice</button>
    </div>
    <div>
      <input type="checkbox" id="hard-mode" />
      <label for="hard-mode">Hard Mode</label>
    </div>
  </div>
  <div class="scoreboard" id="scoreboard"></div>
  <div class="game-area" id="game"></div>
  <div id="result">
    <h2 id="result-text"></h2>
    <button id="copy-results" onClick="copyToKeyboard()">Copy Results</button>
    <button id="play-again" onClick="location.reload()">Play Again</button>
    <div id="result-breakdown"></div>
  </div>
  <div class="rules" id="rules">
    <h3>How to Play</h3>
    <p>Click on the card you believe appears in a higher percentage of decks on <a href="https://edhrec.com"  target="_blank">EDHRec</a>. 
      This percentage represents how often a card is included in decks where it's eligible to be played â€” calculated by dividing the number of decks that include the card by the total number of decks it could appear in.</p>
  </div>

  <!-- Load card list -->
  <script src="./formatted_card_list.js"></script>
  
  <script>
    const mainMenu = document.getElementById("main-menu");
    const scoreboard = document.getElementById("scoreboard");
    const gameArea = document.getElementById("game");
    const result = document.getElementById("result");
    const resultText = document.getElementById("result-text");
    const copyResultsBtn = document.getElementById("copy-results");
    const rules = document.getElementById("rules");

    let cardData = [];
    let currentPair = 0;
    let correctCount = 0;
    let gameType = 0; // 0 = practice, 1 = daily
    let resultToCopy = "";
    let shuffled = [];
    let hardMode = false;
    let resultArray = [];

    // Use the current date (YYYY-MM-DD) as a seed
    const today = new Date().toISOString().split('T')[0];
    const dateObj = new Date();
    const yyyy = dateObj.getUTCFullYear();
    const mm = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
    const dd = String(dateObj.getUTCDate()).padStart(2, '0');
    const dateStr = `${yyyy}-${mm}-${dd}`;
    const dateStrSanatized = `${yyyy}${mm}${dd}`;

    // Simple seeded RNG using Mulberry32
    function mulberry32(seed) {
      let t = seed;
      return function() {
        t |= 0;
        t = (t + 0x6D2B79F5) | 0;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r = (r + Math.imul(r ^ (r >>> 7), 61 | r)) ^ r;
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    // Convert the date string into a numeric seed
    let seed = dateStrSanatized;
    let rng = mulberry32(parseInt(seed));

    // Shuffle using the seeded RNG (Fisher-Yates)
    function shuffleSeeded(array, rng) {
      let a = array.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    async function getCount() {
      fetch('https://api.counterapi.dev/v1/asmrandle/plays')
        .then(res => res.json())
        .then(data => {
          console.log(`Game has been played ${data.value} times.`);
      });
    }

    function increaseCount() {
      fetch('https://api.counterapi.dev/v1/asmrandle/plays/up').catch(() => {
        // Ignore any errors
      });
    }

    // Cookie utility functions
    function setCookie(name, value, days) {
      let expires = "";
      if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }

    function getCookie(name) {
      const nameEQ = name + "=";
      const ca = document.cookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    }

    async function fetchCardData(idx) {
      const name = shuffled[idx++];
        try {
          const cardRes = await fetch(`https://json.edhrec.com/pages/cards/${name}.json`);
          if (!cardRes.ok) return fetchCardData(20 +idx);
          const data = await cardRes.json();
          const card = data?.container?.json_dict?.card;
          if (!card) return fetchCardData(20 +idx);
          const inclusion = parseFloat(card.inclusion);
          const potential = parseFloat(card.potential_decks);
          let flavorText = "No flavor text available";
          let imageUrl = card.image_uris?.[0]?.normal || null;
          let artImg = null;
          if (hardMode) {
            try {
              const scryfallRes = await fetch(`https://api.scryfall.com/cards/${card.id}`);
              if (!scryfallRes.ok) return fetchCardData(20 +idx);
              const scryfallData = await scryfallRes.json();
              flavorText = scryfallData?.flavor_text || "No flavor text available";
              artImg = scryfallData?.image_uris?.art_crop || imageUrl;
            } catch (err) {
              return fetchCardData(20 +idx);
            }
          }
          if (!isFinite(inclusion) || !isFinite(potential) || potential === 0) return fetchCardData(20 +idx);
          const popularity = (inclusion / potential) * 100;
          return ({
            name,
            popularity,
            img: imageUrl,
            artImg,
            flavorText
          });
        } catch (err) {
          // on network / parse error, skip this card and continue
          return fetchCardData(20 +idx);
        }
    }

    async function loadCards(type) {
      hardMode = document.querySelector("#hard-mode").checked;
      mainMenu.style.display = "none";
      if (type === 'daily') {
        todayCookie = getCookie(`${dateStrSanatized}`);
        if (todayCookie !== null) {
          resultText.textContent = `You have already played today's Asmrandle! Come back tomorrow for a new challenge. Your score was ${todayCookie}/10.`;
          resultToCopy = `${todayCookie}/10 | ${dateStr} | https://asmrandle.com`;
          gameArea.style.display = "none";
          result.style.display = "block";
          return;
        }
        gameType = 1;
        shuffled = shuffleSeeded(window.cardList, rng); // shuffle with seed for daily mode
      } else {
        shuffled = [...window.cardList].sort(() => 0.5 - Math.random()); // shuffle full list
      }

      let idx = 0;
      while (idx < 20) {
        const name = shuffled[idx++];
        cardData.push({
          name,
          popularity: null,
          img: null,
          artImg: null,
          flavorText: null
        });
      }

      await fetchCardData(0).then(data => {
        cardData[0] = data;
      });
      await fetchCardData(1).then(data2 => {
        cardData[1] = data2;
      });
      for (let i = 0; i < 10; i++) {
        const dot = document.createElement("div");
        dot.className = "dot";
        scoreboard.appendChild(dot);
      }
      showNextPair();
    }

    function saveResults() {
        increaseCount();
        if (gameType === 1) {
          copyResultsBtn.style.display = "inline-block";
          setCookie(`${dateStrSanatized}`, `${resultToCopy}|${correctCount}`, 2147483647); // Set cookie to never expire
          showResults();
        } else {
          copyResultsBtn.style.display = "none";
          showResults();
        }
        return;
    }

    function showResults() {
      gameArea.style.display = "none";
      result.style.display = "block";
      if (gameType === 1) {
        resultText.textContent = `Asmrandle, ${dateStr} | ${correctCount}/10 correct`;
        resultToCopy += ` ${correctCount}/10 ${hardMode? "| Hard Mode " : ""}| ${dateStr} | https://asmrandle.com`
      } else {
        resultText.textContent = `You got ${correctCount}/10 correct.`;
      }
      const resultBreakdown = document.getElementById("result-breakdown");
      for (let i = 0; i < 10; i++) {
        const correct = resultArray[i];
        const div = document.createElement("div");
        div.className = "result-item";
        div.classList.add(correct ? "result-item-winner" : "result-item-loser");
        const card = cardData[i * 2];
        const card2 = cardData[i * 2 + 1];
        
        // Create first card container
        const card1Container = document.createElement("div");
        card1Container.className = "result-card";
        const img1 = document.createElement("img");
        img1.src = card.img;
        const winner = card.popularity >= card2.popularity;
        if (winner) {
          card1Container.classList.add("result-winner");
        } else {
          card1Container.classList.add("result-loser");
        }
        const overlay1 = document.createElement("div");
        overlay1.className = "result-popularity-overlay";
        overlay1.textContent = `${card.popularity.toFixed(3)}%`;
        card1Container.appendChild(img1);
        card1Container.appendChild(overlay1);
        
        // Create second card container
        const card2Container = document.createElement("div");
        card2Container.className = "result-card";
        const img2 = document.createElement("img");
        img2.src = card2.img;
        if (!winner) {
          card2Container.classList.add("result-winner");
        } else {
          card2Container.classList.add("result-loser");
        }
        const overlay2 = document.createElement("div");
        overlay2.className = "result-popularity-overlay";
        overlay2.textContent = `${card2.popularity.toFixed(3)}%`;
        card2Container.appendChild(img2);
        card2Container.appendChild(overlay2);
        
        div.appendChild(card1Container);
        div.appendChild(card2Container);
        resultBreakdown.appendChild(div);
      }
    }

    function showNextPair() {
      if (currentPair >= 10) {
        saveResults();
        return;
      }

      gameArea.innerHTML = "";
      const card1 = cardData[currentPair * 2];
      const card2 = cardData[currentPair * 2 + 1];

      [card1, card2].forEach((card, i) => {
        const div = document.createElement("div");
        div.className = "card";
        const img = document.createElement("img");
        img.src = hardMode ? card.artImg : card.img;
        div.appendChild(img);
        if (hardMode) {
          const overlay = document.createElement("div");
          overlay.className = "flavorOverlay";
          overlay.textContent = `${card.flavorText}`;
          div.appendChild(overlay);
        }
        div.onclick = () => handleChoice(i === 0 ? card1 : card2, i === 0 ? card2 : card1, div);
        gameArea.appendChild(div);
      });
    }

    function copyToKeyboard() {
      navigator.clipboard.writeText(resultToCopy);
    }

    async function handleChoice(chosen, other, div) {
      gameArea.querySelectorAll(".card").forEach(c => c.onclick = null);
      const overlays = [];
      const cards = document.querySelectorAll(".card");

      cards.forEach((c, i) => {
        const overlay = document.createElement("div");
        overlay.className = "overlay";
        const isChosen = (i === 0 && chosen === cardData[currentPair*2]) || (i === 1 && chosen === cardData[currentPair*2+1]);
        const card = isChosen ? chosen : other;
        const higherPopularity = cardData[currentPair*2].popularity > cardData[currentPair*2+1].popularity;
        const color = higherPopularity && card === cardData[currentPair*2] || !higherPopularity && card === cardData[currentPair*2+1] ? "rgba(0,128,0,0.6)" : "rgba(128,0,0,0.6)";
        overlay.style.background = color;
        overlay.textContent = `${card.popularity.toFixed(3)}%`;
        c.appendChild(overlay);
        overlays.push(overlay);
      });

      const correct = chosen.popularity >= other.popularity;
      scoreboard.children[currentPair].style.background = correct ? "green" : "red";
      if (correct) {
        correctCount++
        resultToCopy += "ðŸŸ©";
        resultArray[currentPair] = true;
      } else {
        resultToCopy += "ðŸŸ¥";
        resultArray[currentPair] = false;
      };

      currentPair++;
      const idx1 = currentPair * 2;
      const idx2 = idx1 + 1;
      await fetchCardData(idx1).then(data => {
          cardData[idx1] = data;
      });
      await fetchCardData(idx2).then(data2 => {
          cardData[idx2] = data2;
      });
      setTimeout(() => {
        overlays.forEach(o => o.remove());
        showNextPair();
      }, 2800);
    }
  </script>
</body>
</html>
